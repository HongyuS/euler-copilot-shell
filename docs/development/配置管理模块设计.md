# 配置管理模块设计

## 方案设计

### 整体方案设计

配置管理模块提供应用程序的配置存储、读取和管理功能，支持多后端配置、运行时配置变更和配置验证。

#### 模块架构

```mermaid
graph TB
    subgraph "配置数据模型"
        A[ConfigModel<br/>主配置模型] --> B[Backend<br/>后端枚举]
        A --> C[OpenAIConfig<br/>OpenAI配置]  
        A --> D[EulerIntelliConfig<br/>Hermes配置]
        A --> E[LogLevel<br/>日志级别]
    end
    
    subgraph "配置管理层"
        F[ConfigManager<br/>配置管理器] --> G[load_settings<br/>加载配置]
        F --> H[save_settings<br/>保存配置]
        F --> I[getter/setter<br/>配置访问方法]
    end
    
    subgraph "持久化存储"
        J[JSON序列化<br/>to_dict/from_dict] --> K[配置文件<br/>smart-shell.json]
        K --> L[用户目录<br/>~/.config/eulerintelli/]
    end
    
    subgraph "配置验证"
        M[枚举验证<br/>Backend/LogLevel]
        N[类型验证<br/>dataclass]
        O[默认值管理<br/>field defaults]
    end
    
    F --> A
    F --> J
    I --> H
    G --> K
    A --> M
    A --> N
    A --> O
```

#### 核心功能

1. **多后端配置管理**: 支持 OpenAI 和 openEuler Intelligence 后端配置
2. **持久化存储**: 自动保存配置到用户配置目录
3. **运行时热更新**: 支持运行时配置修改并立即生效
4. **类型安全**: 使用 dataclass 和枚举确保类型安全
5. **默认值体系**: 提供合理的开箱即用默认配置

### 详细设计

#### 配置数据模型设计

```mermaid
classDiagram
    class ConfigModel {
        +backend: Backend
        +openai: OpenAIConfig
        +eulerintelli: HermesConfig
        +log_level: LogLevel
        +to_dict() dict
        +from_dict(data: dict) ConfigModel
    }
    
    class Backend {
        <<enumeration>>
        OPENAI
        EULERINTELLI
    }
    
    class LogLevel {
        <<enumeration>>
        DEBUG
        INFO
        WARNING
        ERROR
    }
    
    class OpenAIConfig {
        +base_url: str
        +model: str
        +api_key: str
        +to_dict() dict
        +from_dict(data: dict) OpenAIConfig
    }
    
    class HermesConfig {
        +base_url: str
        +api_key: str
        +default_app: str
        +to_dict() dict
        +from_dict(data: dict) HermesConfig
    }
    
    ConfigModel --> Backend
    ConfigModel --> LogLevel
    ConfigModel --> OpenAIConfig
    ConfigModel --> HermesConfig
```

#### 配置管理器设计

```mermaid
classDiagram
    class ConfigManager {
        +data: ConfigModel
        +config_path: Path
        +GLOBAL_CONFIG_PATH: Path
        +USER_CONFIG_PATH: Path
        +get_backend() Backend
        +set_backend(backend: Backend) None
        +get_base_url() str
        +set_base_url(url: str) None
        +get_model() str
        +set_model(model: str) None
        +get_api_key() str
        +set_api_key(key: str) None
        +get_eulerintelli_url() str
        +set_eulerintelli_url(url: str) None
        +get_eulerintelli_key() str
        +set_eulerintelli_key(key: str) None
        +get_default_app() str
        +set_default_app(app_id: str) None
        +get_log_level() LogLevel
        +set_log_level(level: LogLevel) None
        +create_deployment_manager() ConfigManager
        +ensure_user_config_exists() bool
        +create_global_template() bool
        +validate_and_update_config() bool
        -_load_settings() None
        -_save_settings() None
    }
    
    ConfigManager --> ConfigModel
```

#### 配置加载流程

```mermaid
flowchart TD
    A[ConfigManager 初始化] --> B[设置配置文件路径]
    B --> C{配置文件存在?}
    
    C -->|是| D[读取JSON文件]
    C -->|否| E[使用默认配置]
    
    D --> F{JSON格式正确?}
    F -->|是| G[解析为ConfigModel]
    F -->|否| H[记录错误使用默认配置]
    
    G --> I[配置加载完成]
    E --> I
    H --> I
    
    I --> J[应用程序正常运行]
```

#### 配置保存机制

```mermaid
flowchart TD
    A[配置值更改] --> B[调用setter方法]
    B --> C[更新内存中的配置]
    C --> D[触发_save_settings]
    
    D --> E{父目录存在?}
    E -->|否| F[创建父目录]
    E -->|是| G[序列化为JSON]
    F --> G
    
    G --> H[写入配置文件]
    H --> I{写入成功?}
    
    I -->|是| J[配置保存完成]
    I -->|否| K[记录错误日志]
    
    K --> L[抛出异常]
    J --> M[继续执行]
```

#### 配置文件结构

配置文件位置: `~/.config/eulerintelli/smart-shell.json`

```mermaid
graph LR
    subgraph "配置文件结构"
        A[smart-shell.json] --> B[backend: 后端选择]
        A --> C[openai: OpenAI配置]
        A --> D[eulerintelli: Hermes配置]
        A --> E[log_level: 日志级别]
        
        C --> F[base_url: API地址]
        C --> G[model: 模型名称]
        C --> H[api_key: API密钥]
        
        D --> I[base_url: 服务地址]
        D --> J[api_key: 认证令牌]
        D --> K[default_app: 默认智能体ID]
    end
```

#### 配置验证策略

```mermaid
stateDiagram-v2
    [*] --> ValidateType: 开始验证
    
    ValidateType --> CheckEnum: 检查枚举值
    CheckEnum --> ValidBackend: backend 有效
    CheckEnum --> ValidLogLevel: log_level 有效
    CheckEnum --> InvalidEnum: 枚举值无效
    
    ValidBackend --> CheckURLs: 验证URL格式
    ValidLogLevel --> CheckURLs
    
    CheckURLs --> ValidURL: URL格式正确
    CheckURLs --> InvalidURL: URL格式错误
    
    ValidURL --> CheckRequired: 检查必填字段
    CheckRequired --> AllRequired: 所有必填字段存在
    CheckRequired --> MissingRequired: 缺少必填字段
    
    AllRequired --> [*]: 验证通过
    
    InvalidEnum --> UseDefault: 使用默认值
    InvalidURL --> UseDefault
    MissingRequired --> UseDefault
    
    UseDefault --> [*]: 使用默认配置
```

#### 默认值管理

```mermaid
classDiagram
    class DefaultValues {
        <<static>>
        +OPENAI_BASE_URL: ""
        +OPENAI_MODEL: ""
        +OPENAI_API_KEY: ""
        +HERMES_BASE_URL: "http://127.0.0.1:8002"
        +HERMES_API_KEY: ""
        +HERMES_DEFAULT_APP: ""
        +DEFAULT_BACKEND: Backend.EULERINTELLI
        +DEFAULT_LOG_LEVEL: LogLevel.DEBUG
    }
    
    class ConfigFactory {
        +create_default_config() ConfigModel
        +create_openai_config() OpenAIConfig
        +create_hermes_config() EulerIntelliConfig
    }
    
    ConfigFactory --> DefaultValues
```

#### 配置更新通知机制

```mermaid
sequenceDiagram
    participant U as 用户界面
    participant CM as ConfigManager
    participant BF as BackendFactory
    participant TUI as TUI应用

    U->>CM: set_backend(EULERINTELLI)
    CM->>CM: 更新内存配置
    CM->>CM: _save_settings()
    CM->>U: 配置保存完成
    
    U->>TUI: 通知配置更改
    TUI->>TUI: refresh_llm_client()
    TUI->>BF: create_client(ConfigManager)
    BF->>CM: get_backend()
    BF->>CM: get_eulerintelli_url()
    BF->>BF: 创建新客户端
    BF->>TUI: 返回新客户端
    TUI->>TUI: 更新内部客户端引用
```
